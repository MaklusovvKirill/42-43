# 42-43


ПАРАГРАФ 42 1. **Что такое стек? Какие операции со стеком разрешены?**
   Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO, Last In First Out). Основные операции, разрешённые со стеком:
   - **Push**: добавление элемента на вершину стека.
   - **Pop**: удаление элемента с вершины стека.
   - **Peek (или Top)**: получение значения элемента на вершине стека без его удаления.
   - **IsEmpty**: проверка, пуст ли стек.

2. **Как используется системный стек при выполнении программ?**
   Системный стек используется для хранения информации о вызовах функций, включая адреса возврата, параметры функций и локальные переменные. Каждый раз, когда вызывается функция, создаётся новый фрейм стека, который помещается на вершину стека. Когда функция завершает выполнение, фрейм удаляется, и управление передаётся обратно по адресу возврата.

3. **Какие ошибки могут возникнуть при использовании стека?**
   - **Переполнение стека (Stack Overflow)**: происходит, когда стек заполняется, и происходит попытка добавить новый элемент.
   - **Недостаток стека (Stack Underflow)**: возникает, когда происходит попытка удалить элемент из пустого стека.

4. **В каких случаях можно использовать обычный массив для моделирования стека?**
   Обычный массив можно использовать для моделирования стека, когда известен максимальный размер стека заранее. Это позволяет эффективно управлять памятью и обеспечивать быстрый доступ к элементам. Однако, если размер стека может изменяться, лучше использовать динамические структуры данных.

5. **Как построить стек на основе динамического массива?**
   Для построения стека на основе динамического массива можно использовать следующий подход:
   - Создать массив фиксированного размера.
   - Поддерживать переменную, указывающую на вершину стека (например, `top`).
   - При добавлении элемента (push) увеличивать `top` и помещать элемент в массив.
   - При удалении элемента (pop) уменьшать `top` и возвращать элемент из массива.
   - При необходимости увеличивать размер массива, если он переполняется.

6. **Почему при передаче стека в подпрограммы, приведённые в параграфе, соответствующий параметр должен быть изменяемым?**
   Стек может изменяться в процессе выполнения подпрограммы (например, добавление или удаление элементов). Если стек передан как неизменяемый параметр, изменения, внесённые в стек внутри подпрограммы, не будут отражены в вызывающем коде. Поэтому стек должен передаваться по ссылке или как изменяемый параметр, чтобы изменения были видны вне подпрограммы.

7. **Что такое очередь? Какие операции она допускает?**
   Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO, First In First Out). Основные операции, разрешённые с очередью:
   - **Enqueue**: добавление элемента в конец очереди.
   - **Dequeue**: удаление элемента из начала очереди.
   - **Peek (или Front)**: получение значения элемента в начале очереди без его удаления.
   - **IsEmpty**: проверка, пуста ли очередь.

8. **Приведите примеры задач, в которых можно использовать очередь.**
   - **Управление задачами в операционных системах**: очереди используются для управления процессами и задачами, ожидающими выполнения.
   - **Обработка запросов на сервере**: запросы пользователей могут обрабатываться в порядке их поступления.
   - **Широковещательная передача данных**: в сетевых протоколах данные могут передаваться в порядке их поступления.
   - **Моделирование очередей в магазинах или банках**: для анализа времени ожидания клиентов.
  

ПАРАГРАФ 43 



1. **Определения понятий:**
   - **Дерево**: это структура данных, состоящая из узлов, где каждый узел может иметь ноль или более дочерних узлов. Дерево имеет единственный корень, от которого исходят все остальные узлы.
   - **Корень**: это верхний узел дерева, который не имеет родителя.
   - **Лист**: это узел дерева, который не имеет дочерних узлов.
   - **Родитель**: узел, который имеет один или более дочерних узлов.
   - **Сын**: узел, который является дочерним по отношению к другому узлу (родителю).
   - **Потомок**: узел, который находится ниже другого узла в иерархии дерева.
   - **Предок**: узел, который находится выше другого узла в иерархии дерева.
   - **Высота дерева**: максимальная длина пути от корня до самого глубокого листа. Высота дерева с одним узлом равна 0.

2. **Где используются структуры типа «дерево» в информатике и в других областях?**
   - **Базы данных**: деревья используются для организации данных (например, B-деревья).
   - **Файловые системы**: структура каталогов и файлов представляется в виде дерева.
   - **Алгоритмы поиска**: деревья поиска (например, бинарные деревья поиска) используются для быстрого поиска данных.
   - **Компьютерная графика**: деревья используются для представления иерархии объектов.
   - **Системы управления версиями**: деревья используются для отслеживания изменений в файлах.

3. **Рекурсивное определение дерева:**
   Дерево можно определить рекурсивно как:
   - Пустое дерево — это дерево.
   - Непустое дерево состоит из корня и поддеревьев, которые также являются деревьями.

4. **Можно ли считать, что линейный список — это частный случай дерева?**
   Да, линейный список можно рассматривать как частный случай дерева, где каждый узел имеет только одного потомка (правого или левого), а все узлы, кроме последнего, имеют только одного сына.

5. **Свойства дерева поиска:**
   - Для каждого узла все значения в левом поддереве меньше значения узла.
   - Для каждого узла все значения в правом поддереве больше значения узла.
   - Левое и правое поддеревья также являются деревьями поиска.

6. **Как построить дерево поиска из массива данных?**
   Для построения дерева поиска из массива данных можно использовать следующий алгоритм:
   - Отсортировать массив.
   - Рекурсивно выбирать средний элемент массива в качестве корня, а затем повторять процесс для левой и правой половин массива, чтобы построить левое и правое поддеревья.

7. **Преимущества поиска с помощью дерева:**
   - Быстрый доступ к данным: среднее время поиска в сбалансированном дереве поиска составляет O(log n).
   - Упрощение операций вставки и удаления по сравнению с линейными структурами данных.
   - Упорядоченное хранение данных, что позволяет легко выполнять обход в порядке возрастания.

8. **Что такое обход дерева?**
   Обход дерева — это процесс посещения всех узлов дерева в определённом порядке.

9. **Способы обхода дерева:**
   - **Прямой обход (Pre-order)**: корень, левое поддерево, правое поддерево.
   - **Симметричный обход (In-order)**: левое поддерево, корень, правое поддерево.
   - **Обратный обход (Post-order)**: левое поддерево, правое поддерево, корень.
   - **Уровневый обход (Level-order)**: узлы посещаются по уровням, начиная с корня.
   - Другие способы могут включать обход по спирали или обход с использованием различных критериев.

10. **Как строится дерево для вычисления арифметического выражения?**
    Дерево для вычисления арифметического выражения строится, где каждый узел представляет оператор (например, +, -, *, /), а его дочерние узлы представляют операнды (числа или подвыражения). Приоритет операторов определяет структуру дерева.

11. **Как можно представить дерево в программе на Паскале?**
    В Паскале дерево можно представить с помощью записи (record), содержащей данные узла и указатели на левого и правого сына:
    ```pascal
    type
      PNode = ^TNode;
      TNode = record
        Data: Integer;
        Left, Right: PNode;
      end;
    ```

12. **Как указать, что узел дерева не имеет левого (правого) сына?**
    Для указания, что узел не имеет левого или правого сына, можно установить соответствующий указатель (Left или Right) в `nil`.

13. **Как выделяется память под новый узел?**
    Память под новый узел выделяется с помощью оператора `new` в Паскале:
    ```pascal
    var
      NewNode: PNode;
    begin
      New(NewNode);
      NewNode^.Data := Value; // Присваиваем значение
      NewNode^.Left := nil;   // Инициализируем указатели
      NewNode^.Right := nil;
    end;
    ```

14. **Почему рекурсивные алгоритмы работы с деревьями получаются проще, чем нерекурсивные?**
    Рекурсивные алгоритмы проще, потому что они естественно соответствуют иерархической структуре дерева. Рекурсия позволяет легко обрабатывать поддеревья, не требуя явного управления стеком вызовов и сложной логики для обхода.

15. **Как хранить двоичное дерево в массиве? Можно ли использовать такой приём для хранения деревьев, в которых узлы могут иметь больше двух сыновей?**
    Двоичное дерево можно хранить в массиве, где для узла с индексом `i`:
    - Левый сын находится по индексу `2*i + 1`.
    - Правый сын находится по индексу `2*i + 2`.
    
    Для деревьев, в которых узлы могут иметь больше двух сыновей, такой подход не подходит, так как необходимо будет использовать более сложные структуры, например, массивы списков или указатели, чтобы хранить произвольное количество дочерних узлов.
